#!/bin/bash

gitbranch() {
  branch_id=$(git branch 2>/dev/null | grep '^*' | cut -c 2-)
  if [ $branch_id ]
  then
    printf $branch_id
    printf " "
  fi
}

function current_user() {
  if [ -n "$USER" ]; then
    printf "$USER"
  else
    printf "$USERNAME"
  fi
}

# turns the #123b84 color codes to 203;133;54 rgb codes
hex_color_to_rgb() {
  hex=${1#"#"}

  r=$((0x${hex:0:2}))
  g=$((0x${hex:2:2}))
  b=$((0x${hex:4:2}))

  printf "%d;%d;%d\n" "$r" "$g" "$b"
}

# turns all hex symbols to rgb
prepare_colors() {
  palette_primary=$(hex_color_to_rgb $palette_primary)
  palette_primary_dark=$(hex_color_to_rgb $palette_primary_dark)
  palette_secondary=$(hex_color_to_rgb $palette_secondary)
  palette_secondary_dark=$(hex_color_to_rgb $palette_secondary_dark)
  palette_accent=$(hex_color_to_rgb $palette_accent)
  palette_accent_dark=$(hex_color_to_rgb $palette_accent_dark)
  palette_gradient_start=$(hex_color_to_rgb $palette_gradient_start)
  palette_gradient_end=$(hex_color_to_rgb $palette_gradient_end)
  palette_variant_1=$(hex_color_to_rgb $palette_variant_1)
  palette_variant_2=$(hex_color_to_rgb $palette_variant_2)
  palette_variant_3=$(hex_color_to_rgb $palette_variant_3)
  palette_text=$(hex_color_to_rgb $palette_text)
}

# Inserts a "255;255;255" formatted code inside ansi color code
rgb_fg() {
  printf "\[\033[38;2;${1}m\]"
}

rgb_bg() {
  printf "\[\033[48;2;${1}m\]"
}

rgb_bg_esc() {
  printf "\033[48;2;${1}m"
}

rgb_fg_esc() {
  printf "\033[38;2;${1}m"
}

xterm_fg() {
  printf "\[\033[38;5;${1}m\]"
}

xterm_bg() {
  printf "\[\033[48;5;${1}m\]"
}

xterm_bg_esc() {
  printf "\033[48;5;${1}m"
}

no_color() {
  printf "\[\033[0m\]"
}

no_color_esc() {
  printf "\033[0m\033[49m"
}

# Gradient over start and end rgb string formatted as "255;255;255"
rgb_gradient() {
  start_color=$1
  end_color=$2
  str=${*:3}
  str_len=${#str}

  if [ $str_len != 0 ] 
  then 
    IFS=';' read r1 g1 b1 <<< "$start_color"
    IFS=';' read r2 g2 b2 <<< "$end_color"

    dr=$((r2 - r1))
    dg=$((g2 - g1))
    db=$((b2 - b1))

    rstep=$((dr / str_len))
    gstep=$((dg / str_len))
    bstep=$((db / str_len))

    for i in $(seq 0 $((str_len))); do
      r3=$((r1 + rstep*i))
      g3=$((g1 + gstep*i))
      b3=$((b1 + bstep*i))
      printf "\[\033[38;2;${r3};${g3};${b3}m\]${str:i:1}"
    done
    printf "\[\033[0m\]"
  fi
}

# Gradient over start and end rgb string formatted as "255;255;255"
rgb_gradient_partial() {
  start_color=$1
  end_color=$2
  partial_percent=$3
  str=${*:4}
  str_len=${#str}
  steps=$((str_len - $partial_percent /  100))

  if [ $str_len != 0 ] 
  then 
    IFS=';' read r1 g1 b1 <<< "$start_color"
    IFS=';' read r2 g2 b2 <<< "$end_color"

    dr=$((r2 - r1))
    dg=$((g2 - g1))
    db=$((b2 - b1))

    rstep=$((dr / steps))
    gstep=$((dg / steps))
    bstep=$((db / steps))


    for i in $(seq 0 $((steps))); do
      r3=$((r1 + rstep*i))
      g3=$((g1 + gstep*i))
      b3=$((b1 + bstep*i))
      printf "\[\033[38;2;${r3};${g3};${b3}m\]${str:i:1}"
    done
    printf "\[\033[0m\]"
  fi
}

# unescaped gradient for demos
rgb_gradient_esc() {
  start_color=$1
  end_color=$2
  str=${*:3}
  str_len=${#str}

  if [ $str_len != 0 ] 
  then 
    IFS=';' read r1 g1 b1 <<< "$start_color"
    IFS=';' read r2 g2 b2 <<< "$end_color"

    dr=$((r2 - r1))
    dg=$((g2 - g1))
    db=$((b2 - b1))

    rstep=$((dr / str_len))
    gstep=$((dg / str_len))
    bstep=$((db / str_len))

    for i in $(seq 0 $((str_len))); do
      r3=$((r1 + rstep*i))
      g3=$((g1 + gstep*i))
      b3=$((b1 + bstep*i))
      printf "\033[48;2;${r3};${g3};${b3}m${str:i:1}"
    done
    printf "\033[0m"
  fi
}

# Gradient over bash 256 color codes, 
# takes starting color code and number of codes to gradient over
code_gradient() {
  COUNTER=0
  COLOR=$1
  COLS=$2
  TXT=${*:3}
  MOD="$(($((${#TXT}/${COLS}))*2))"
  if [ $MOD == 0 ]
  then
	  mod=1
  fi
  for (( i=0; i<${#TXT}; i++ )); do  
    printf "\e[38;5;${COLOR}m${TXT:COUNTER:1}"
    COUNTER=$(expr $COUNTER + 1)
    if [ $((i%$MOD)) == 0 ]
    then 
      COLOR=$(expr $COLOR + 1)
    fi
  done
}

long_datetime() {
	TMP_DATE=$(date "+%A %d %B %Y %T")
	printf "$TMP_DATE"
}

short_datetime() {
	TMP_DATE=$(date "+%a %d %b %T")
	printf "$TMP_DATE"
}

long_date() {
  printf "$(date "+%A %d %B")"
}

short_date() {
	TMP_DATE=$(date "+%a %d %b")
	printf "$TMP_DATE"
}

short_time() {
  TMP_TIME=$(date "+%T")
	printf "$TMP_TIME"
}

# center_string() {
#   local string="$1"
#   local padding=$(( ($COLUMNS - ${#string}) / 2 ))
#   printf '%*s%s%*s\n' $padding '' "$string" $padding ''
# }

center_string() {
  local string="$1"
  local padding=$(( ($(tput cols) - ${#string}) / 2))
  printf '%*s%s%*s\n' $padding '' "$string" $padding ''
}

fetch_weather_data() {
    WEATHER_FILE="/tmp/weather_data_001.txt"
    while true; do
        WEATHER_DATA=$(curl -s 'https://weatherapi.pelmorex.com/api/v1/observation/placecode/caqc0313?locale=fr-ca&unit=metric')
        TEMPERATURE=$(echo "$WEATHER_DATA" | python -c "import sys, json; print(json.load(sys.stdin)['observation']['temperature'])")
        WEATHER_DESC=$(echo "$WEATHER_DATA" | python -c "import sys, json; print(json.load(sys.stdin)['observation']['weatherCode']['text'])")
        echo "$TEMPERATURE $WEATHER_DESC" > "$WEATHER_FILE"
        sleep 30
    done
}
